Лабораторная 3.

Написать две функции: выполняющие преобразование изображения из цветового пространства RGB в YUV (YCbCr 601, PC-range) и обратно. Для вычислений использовать целочисленную арифметику (фиксированную точку) и SIMD-команды.

Прототипы функций:

```
void RGB2YUV(const uint8_t *in, uint8_t *restrict out, size_t width, size_t height, ptrdiff_t in_stride, ptrdiff_t out_stride);
```

```
void YUV2RGB(const uint8_t *in, uint8_t *restrict out, size_t width, size_t height, ptrdiff_t in_stride, ptrdiff_t out_stride);
```

\_stride – расстояние (в байтах, со знаком) между первой точкой одной строки и первой точкой следующей строки.

RGB данные лежат в памяти в порядке: R G B R G B...
YUV данные лежат в памяти в порядке: Y U V X Y U V X... , где X – произвольное значение (0 при записи, не учитывается при чтении).

Оцениваться будет как правильность работы, так и скорость. За указанные размеры буферов выходить нельзя.

64-битный код, конвенция вызова: fastcall64. Не забывайте сохранять нужные регистры, если вы их изменяете. Функции должны быть реализованы в одном .asm файле и не использовать каких-либо внешних функций (использовать свои дополнительные функции в том же файле – разрешается).

Разрешается использовать любые расширенные команды, поддерживаемые процессорами архитектуры Skylake (стоит на сервере). Если нужно что-то из более нового (вплоть до поддерживаемого Zen4) – спрашивайте.
